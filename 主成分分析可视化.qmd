---
title: "主成分分析可视化"
---

网络上很多R语言主成分分析可视化都是基于R语言实战进行修改，今天为大家介绍更好用的R包，在之前聚类分析中也经常用到：`factoextra`和`factoMineR`，关于主成分分析的可视化，大家比较常见的可能是`ggbiplot`，这几个R包都挺不错，大家可以比较下。

初次之外，再介绍下如何提取数据并使用`ggplot2`自己绘制PCA的结果，以及如何进行3D版的PCA可视化。

`factoextra`和`factoMineR`可以直接使用`prcomp()`函数的结果，也可以使用`FactoMineR`的`PCA()`函数进行，结果更加详细。

## factoextra
### 进行PCA分析

使用R语言自带的`iris`鸢尾花数据进行演示。

```{r}
rm(list = ls())
library(factoextra)
library(FactoMineR)

pca.res <- PCA(iris[,-5], graph = F, scale.unit = T) # 简简单单1行代码实现主成分分析
pca.res
```

结果信息丰富，可以通过不断的$获取，也可以通过特定函数提取，下面介绍。

### 特征值可视化

获取特征值、方差贡献率和累积方差贡献率，可以看到和上一篇的结果是一样的：

```{r}
get_eigenvalue(pca.res)
```

结果中的这几个概念解释请参考前面。

通过这几个值，可以确定主成分个数，当然也可以通过碎石图（就是方差解释度的可视化）直观的观察：

```{r}
fviz_eig(pca.res,addlabels = T,ylim=c(0,100))
```

### 提取变量结果

通过get_pca_var()`函数实现：

```{r}
res.var <- get_pca_var(pca.res)
res.var$cor
res.var$coord          
res.var$contrib       
res.var$cos2        
```

- `res.var$cor`:变量和主成分的相关系数
- `res.var$coord`: 变量在主成分投影上的坐标，下面会结合图说明，因为进行了标准化，所以和相关系数结果一样，其数值代表了主成分和变量之间的相关性
- `res.var$cos2`: 是coord的平方，也是表示主成分和变量间的相关性，同一个变量所有cos2的总和是1
- `res.var$contrib`: 变量对主成分的贡献

这几个结果都可以进行可视化。

### 变量结果可视化

使用`fviz_pca_var()`对变量结果进行可视化：

```{r}
fviz_pca_var(pca.res)
```

`res.var$coord`是变量在主成分投影上的坐标，`Sepal.Width`在`Dim.1`的坐标是-0.4601427，在`Dim.2`的坐标是0.88271627，根据这两个坐标就画出来`Sepal.Width`那根线了，以此类推~

#### 变量和主成分的cos2可视化

`cos2`是coord的平方，也是表示主成分和变量间的相关性，所以首先可以画相关图：

```{r}
library("corrplot")
corrplot(res.var$cos2, is.corr = F)
```

可以看到`Petal.Length`、`Petal.Width`和`Dim1`的相关性比较强，`Sepal.Width`和`Dim2`的相关性比较强。

通过`fviz_cos2()`查看变量在不同主成分的总和，以下是不同变量在第1和第2主成分的加和，如果把`axes = 1:2`改成`axes = 1:4`，就会变成都是1（这个数据最多4个主成分，同一变量的cos2在所有主成分的总和是1）。

```{r}
fviz_cos2(pca.res, choice = "var", axes = 1:2)
```

可以通过`col.var = "cos2"`参数给不同变量按照cos2的数值大小上色：

```{r}
fviz_pca_var(pca.res, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE 
             )
```

```{r}
# 黑白版本
fviz_pca_var(pca.res, alpha.var = "cos2")
```

#### 变量对主成分的贡献可视化

```{r}
res.var$contrib
```

首先也是可以通过画相关性图进行可视化：

```{r}
library("corrplot")
corrplot(res.var$contrib, is.corr=FALSE) 
```

通过`fviz_contrib()`可视化变量对不同主成分的贡献：

```{r}
# 对第1主成分的贡献
fviz_contrib(pca.res, choice = "var", axes = 1)
```

```{r}
# 对第1和第2主成分的贡献
fviz_contrib(pca.res, choice = "var", axes = 1:2)
```

通过`col.var = "contrib"`参数给不同变量按照contrib的数值大小上色：

```{r}
fviz_pca_var(pca.res, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
             )
```

### Dimension description

```{r}
res.desc <- dimdesc(pca.res, axes = c(1,2), proba = 0.05)
# Description of dimension 1
res.desc$Dim.1
```

### 提取样本结果

使用`get_pca_ind()`提取样本结果，和变量结果类似：

```{r}
res.ind <- get_pca_ind(pca.res)

head(res.ind$coord)          
head(res.ind$contrib)      
head(res.ind$cos2)          
```

3个概念和变量的解释也是类似的，只不过上面是变量（列）和主成分的关系，现在是样本（观测，行）和主成分的关系。

### 样本结果可视化

样本的结果可视化可能是更常见的PCA图形，通过`fviz_pca_ind()`实现：

```{r}
fviz_pca_ind(pca.res)
```

这个图是通过`res.ind$coord`里面的坐标实现的，其实就是不同样本在不同主成分的上面的得分score。

默认的可视化比较简陋，但是可以通过超多参数实现各种精细化的控制，比如把不同的属性映射给点的大小和颜色，实现各种花里胡哨的效果。

比如通过组别上色，就是大家最常见的PCA可视化图形：

```{r}
# 经典图形，是不是很熟悉？
fviz_pca_ind(pca.res,
             geom.ind = "point", # 只显示点，不要文字
             col.ind = iris$Species, # 按照组别上色
             palette = c("#00AFBB", "#E7B800", "#FC4E07"), # 自己提供颜色，或者使用主题
             addEllipses = TRUE, # 添加置信椭圆
             legend.title = "Groups"
             )
```

#### 样本的cos2可视化

使用方法和变量的cos2可视化基本一样，通过更改参数值即可实现：

```{r}
fviz_pca_ind(pca.res,
             col.ind = "cos2", # 按照cos2上色
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE    
             )
```

可以更改点的大小、颜色等，只要设置合适的参数即可：

```{r}
fviz_pca_ind(pca.res, 
             pointsize = "cos2", # 把cos2的大小映射给点的大小
             pointshape = 21, 
             fill = "#E7B800",
             repel = TRUE 
             )
```

同时更改点的大小和颜色当然也是支持的：

```{r}
fviz_pca_ind(pca.res, 
             col.ind = "cos2", # 控制颜色
             pointsize = "contrib", # 控制大小
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE 
             )
```

使用参数`choice = "ind"`可视化样本对不同主成分的cos2：

```{r}
# axes选择主成分
fviz_cos2(pca.res, choice = "ind", axes = 1:2)
```

#### 样本对主成分的贡献可视化

和变量对主成分的贡献可视化非常类似，简单演示下：

```{r}
fviz_contrib(pca.res, choice = "ind", axes = 1:2)
```

### biplot

双标图...

同时展示变量和样本和主成分的关系，超级多的自定义可视化细节。

```{r}
# 同时有箭头和椭圆
fviz_pca_biplot(pca.res, 
                col.ind = iris$Species, 
                palette = "jco", 
                addEllipses = TRUE, 
                label = "var",
                col.var = "black", 
                repel = TRUE,
                legend.title = "Species"
                ) 
```


```{r}
fviz_pca_biplot(pca.res, 
                # 组别映射给点的填充色
                geom.ind = "point",
                pointshape = 21,
                pointsize = 2.5,
                fill.ind = iris$Species,
                col.ind = "black",
                # 通过自定义分组给变量上色
                col.var = factor(c("sepal", "sepal", "petal", "petal")),
                # 自定义图例标题
                legend.title = list(fill = "Species", color = "Clusters"),
                repel = TRUE        
             )+
  ggpubr::fill_palette("jco")+ # 选择点的填充色的配色
  ggpubr::color_palette("npg") # 选择变量颜色的配色
```


```{r}
fviz_pca_biplot(pca.res, 
                # 自定义样本部分
                geom.ind = "point",
                fill.ind = iris$Species, # 填充色
                col.ind = "black", # 边框色
                pointshape = 21, # 点的形状
                pointsize = 2, 
                palette = "jco",
                addEllipses = TRUE,
                # 自定义变量部分
                alpha.var ="contrib", col.var = "contrib",
                gradient.cols = "RdYlBu",
                
                # 自定义图例标题
                legend.title = list(fill = "Species", color = "Contrib",
                                    alpha = "Contrib")
                )
```

`fviz_xxx`系列可视化函数底层是`ggscatter`的封装，这个函数来自`ggpubr`包，所有`ggpubr`支持的特性都可以给`fviz_xxx`函数使用，这也是这几个函数功能强大的原因，毕竟底层都是`ggplot2`!

下载会继续给大家介绍如何提取PCA的数据，并使用`ggplot2`可视化，以及三维PCA图的实现。

`factoextra`和`factoMineR`在聚类分析、主成分分析、因子分析等方面都可以使用。

## ggplot2可视化PCA

下面说一下如何提取数据用`ggplot2`画PCA图，以及三维PCA图。

还是使用鸢尾花数据集。

```{r}
rm(list = ls())

pca.res <- prcomp(iris[,-5], scale. = T, center = T)
pca.res
```

在上一篇中提到过，经典的PCA图的横纵坐标其实就是不同样本在不同主成分中的得分，只要提取出来就可以用`ggplot2`画了。

```{r}
# 提取得分
tmp <- as.data.frame(pca.res$x)
head(tmp)
```

和原数据拼到一起就可以画图了：

```{r}
tmp$species <- iris$Species
head(tmp)
```

```{r}
library(ggplot2)
library(ggsci)

ggplot(tmp, aes(PC1, PC2))+
  geom_point(aes(color = species))+
  stat_ellipse(aes(fill=species), alpha = 0.2,
               geom ="polygon",type = "norm")+
  scale_fill_aaas()+
  scale_color_aaas()+
  theme_bw()
```

## 3d版PCA可视化

其实就是使用3个主成分，之前介绍过一种：[使用R语言美化PCA图](https://mp.weixin.qq.com/s/LTQIWYW86QCOEu7fctF8xQ)，使用方法非常简单，也是在文献中学习到的。

![](figs/Snipaste_2023-06-12_15-40-00.png)

今天再介绍下`scatterplot3d`包。

```{r,fig.height=7,fig.width=7}
library(scatterplot3d)

scatterplot3d(tmp[,1:3], # 第1-3主成分
              # 颜色长度要和样本长度一样，且对应！
              color = rep(c("#00AFBB", "#E7B800", "#FC4E07"),each=50),
              pch = 15,
              lty.hide = 2
              )
legend("topleft",c('Setosa','Versicolor','Virginica'),
fill=c("#00AFBB", "#E7B800", "#FC4E07"),box.col=NA)
```

是不是很简单呢？
